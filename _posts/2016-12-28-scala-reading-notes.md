---
layout: post
title: "Scala Reading Notes"
data: 2016-12-28
tags: [reading notes, scala, optimization]
comments: true
share: false
---

### Scala match and branch table optimization
To use a Scala match expression like a Java switch statement, use this approach:

```scala
// i is an integer
i match {
case 1 => println("January")
case 2 => println("February")
case 3 => println("March")
case 4 => println("April")
case 5 => println("May")
case 6 => println("June")
case 7 => println("July")
case 8 => println("August")
case 9 => println("September")
case 10 => println("October")
case 11 => println("November")
case 12 => println("December")
// catch the default with a variable so you can print it case whoa => println("Unexpected case: " + whoa.toString)
}
```

That example shows how to take an action based on a match. A more functional ap‐ proach returns a value from a match expression:

```scala
val month = i match { 
case 1 => "January" 
case 2 => "February" 
case 3 => "March" 
case 4 => "April" 
case 5 => "May"
case 6 => "June"
case 7 => "July"
case 8 => "August"
case 9 => "September"
case 10 => "October"
case 11 => "November"
case 12 => "December"
case _ => "Invalid month" // the default, catch-all
}
```
When writing simple match expressions like this, it’s recommend to use the @switch annotation. This annotation provides a warning at compile time if the switch can’t be compiled to a tableswitch or lookupswitch.
Compiling your match expression to a tableswitch or lookupswitch is better for performance, because it results in a branch table rather than a decision tree. When a value is given to the expression, it can jump directly to the result rather than working through the decision tree.

> In computer programming, a branch table or jump table is a method of transferring program control (branching) to another part of a program (or a different program that may have been dynamically loaded) using a table of branch or jump instructions. It is a form of multiway branch. The branch table construction is commonly used when programming in assembly language but may also be generated by a compiler, especially when implementing an optimized switch statement where known, small ranges are involved with few gaps.

> A branch table consists of a serial list of unconditional branch instructions that is branched into using an offset created by multiplying a sequential index by the instruction length (the number of bytes in memory occupied by each branch instruction). It relies on the fact that machine code instructions for branching have a fixed length and can be executed extremely efficiently by most hardware, and is most useful when dealing with raw data values that may be easily converted to sequential index values. Given such data, a branch table can be extremely efficient. It usually consists of the following 3 steps:
1. optionally validating the input data to ensure it is acceptable (this may occur without cost as part of the next step, if the input is a single byte and a 256 byte translate table is used to directly obtain the offset below). Also, if there is no doubt about the values of the input, this step can be omitted.
2. transform the data into an offset into the branch table. This usually involves multiplying or shifting (effectively multiplying by a power of 2) it to take into account the instruction length. If a static translate table is used, this multiplying can be performed manually or by the compiler, without any run time cost.
3. branching to an address made up of the base address of the branch table plus the just generated offset. This sometimes involves an addition of the offset onto the program counter register (unless, in some instruction sets, the branch instruction allows an extra index register). This final address usually points to one of a sequence of unconditional branch instructions, or the instruction immediately beyond them (saving one entry in the table).


Here’s the official description from the <a href="http://www.scala-lang.org/api/current/index.html#scala.annotation.switch" >@switch annotation documentation</a>

The effect of the **@switch** annotation is demonstrated with a simple example. First, place the following code in a file named **SwitchDemo.scala**:
```scala
  // Version 1 - compiles to a tableswitch
import scala.annotation.switch class SwitchDemo {
val i = 1
val x = (i: @switch) match {
case 1 => "One" case 2 => "Two" case _ => "Other"
}
}
```
Then compile the code as usual:
```
$ scalac SwitchDemo.scala
```
Compiling this class produces no warnings and creates the **SwitchDemo.class** output
file. Next, disassemble that file with this **javap** command:
```
$ javap -c SwitchDemo
```
The output from this command shows a tableswitch, like this:
```
 16:  tableswitch{ //1 to 2
                1: 50;
                2: 45;
                default: 40 }
```
This shows that Scala was able to optimize your match expression to a tableswitch. (This is a good thing.)



