---
layout: post
title: "Scala Reading Notes"
data: 2016-12-28
tags: [reading notes, scala, optimization]
comments: true
share: false
---

### Scala match and branch table optimization
To use a Scala match expression like a Java switch statement, use this approach:

```scala
// i is an integer
i match {
case 1 => println("January")
case 2 => println("February")
case 3 => println("March")
case 4 => println("April")
case 5 => println("May")
case 6 => println("June")
case 7 => println("July")
case 8 => println("August")
case 9 => println("September")
case 10 => println("October")
case 11 => println("November")
case 12 => println("December")
// catch the default with a variable so you can print it case whoa => println("Unexpected case: " + whoa.toString)
}
```

That example shows how to take an action based on a match. A more functional ap‐ proach returns a value from a match expression:

```scala
val month = i match { 
case 1 => "January" 
case 2 => "February" 
case 3 => "March" 
case 4 => "April" 
case 5 => "May"
case 6 => "June"
case 7 => "July"
case 8 => "August"
case 9 => "September"
case 10 => "October"
case 11 => "November"
case 12 => "December"
case _ => "Invalid month" // the default, catch-all
}
```
When writing simple match expressions like this, it’s recommend to use the @switch annotation. This annotation provides a warning at compile time if the switch can’t be compiled to a tableswitch or lookupswitch.
Compiling your match expression to a tableswitch or lookupswitch is better for performance, because it results in a branch table rather than a decision tree. When a value is given to the expression, it can jump directly to the result rather than working through the decision tree.

> In computer programming, a branch table or jump table is a method of transferring program control (branching) to another part of a program (or a different program that may have been dynamically loaded) using a table of branch or jump instructions. It is a form of multiway branch. The branch table construction is commonly used when programming in assembly language but may also be generated by a compiler, especially when implementing an optimized switch statement where known, small ranges are involved with few gaps.

> A branch table consists of a serial list of unconditional branch instructions that is branched into using an offset created by multiplying a sequential index by the instruction length (the number of bytes in memory occupied by each branch instruction). It relies on the fact that machine code instructions for branching have a fixed length and can be executed extremely efficiently by most hardware, and is most useful when dealing with raw data values that may be easily converted to sequential index values. Given such data, a branch table can be extremely efficient. It usually consists of the following 3 steps:
1. optionally validating the input data to ensure it is acceptable (this may occur without cost as part of the next step, if the input is a single byte and a 256 byte translate table is used to directly obtain the offset below). Also, if there is no doubt about the values of the input, this step can be omitted.
2. transform the data into an offset into the branch table. This usually involves multiplying or shifting (effectively multiplying by a power of 2) it to take into account the instruction length. If a static translate table is used, this multiplying can be performed manually or by the compiler, without any run time cost.
3. branching to an address made up of the base address of the branch table plus the just generated offset. This sometimes involves an addition of the offset onto the program counter register (unless, in some instruction sets, the branch instruction allows an extra index register). This final address usually points to one of a sequence of unconditional branch instructions, or the instruction immediately beyond them (saving one entry in the table).


Here’s the official description from the <a href="http://www.scala-lang.org/api/current/index.html#scala.annotation.switch" >@switch annotation documentation</a>

The effect of the **@switch** annotation is demonstrated with a simple example. First, place the following code in a file named **SwitchDemo.scala**:

```scala
  // Version 1 - compiles to a tableswitch
import scala.annotation.switch class SwitchDemo {
val i = 1
val x = (i: @switch) match {
case 1 => "One" case 2 => "Two" case _ => "Other"
}
}
```
Then compile the code as usual:

```
$ scalac SwitchDemo.scala
```

Compiling this class produces no warnings and creates the **SwitchDemo.class** output file. Next, disassemble that file with this **javap** command:

```
$ javap -c SwitchDemo
```

The output from this command shows a tableswitch, like this:

```
 16:  tableswitch{ //1 to 2
                1: 50;
                2: 45;
                default: 40 }
```

This shows that Scala was able to optimize your match expression to a tableswitch. (This is a good thing.)

---
### Scala Study on Jan 2

```scala
object rationals extends App{
        val x = new Rational(1, 3)
//      println(x.toString)
        x.RationaltoString
        val y = new Rational(5,7)
        val z = new Rational(3,2)
        (x-y-z).RationaltoString
        (z+x*y).RationaltoString //don't get surprice by it can find the right sequence to execute. The precedence of an operator is determined by its first character. Scala has a table to define the order of priority precedence. But the use fo prefiex operation means to make clearer and easy read program, don't get sidetracked. 
        (x+y+z).RationaltoString
//      y.add(y).RationaltoString
//      val a = new Rational(1,0)
        val a = new Rational(2)
        a.RationaltoString
}


class Rational(x: Int, y: Int)
{
        require(y!=0, "denominator is zero! What is wrong with you!") // require vs assert: require:illegalArgumentException, assert: AssertionError, require: used to enforce a precondition on the caller of the function, assert: to check the code of the function itself. 
            
        def this(x: Int) = this(x, 1)
        private def gcd (x: Int, y: Int): Int = if (y == 0) x else gcd(y, x % y) // recursive method needs result type
        val numer = x/gcd(x, y) // var or val: passing by value, def: passing by name. Also val numer=x/gcd(x,y) is better than def number=x/gcd(x,y) if numer or denom are frequently called, because val avoid repeating re-computation, and number, denom can be called directly
        val denom = y/gcd(x, y)
            
        def RationaltoString: Unit = println(numer + "/" + denom) // use this because I didnt' install compile on runtime, to I still need to println. 
//      override def toString  = numer + "/" + denom // succeed. 
//      override with def toString: Unit = println (numer + "/" + denom) // unsucceed, because return value type is changed. But it is not a new function and a used nanme with the same signiture, compiler can't tell which function (the toString in string or the toString you define) to use. So you can't use this in this way
//      def toString(f: (Int, Int) => Int) = println(numer/f(numer, denom) + "/" + denom/f(numer, denom)) // succeed
            
//      def add ( r: Rational) = // return value type can be inferred from context, so it is optional in this curcumstance 
//              new Rational(numer*r.denom + denom*r.numer, denom*r.denom) 
        def + ( r: Rational) = // return value type can be inferred from context, so it is optional in this curcumstance 
                new Rational(numer*r.denom + denom*r.numer, denom*r.denom)  // infix operation! most characters are valied for identifiers, so use it! 
                    
//      def neg = new Rational(-numer, denom) //self reference: this.numer = numer, same for denom
        def unary_- = new Rational(-numer, denom) // so to use -x and differetiate from x - y, use unary_- instead. Mark that there is a space after unary_- .

//      def sub(r: Rational) = this.+ (r.neg)
        def - (r: Rational) = this + -r

        def * (r: Rational) = new Rational( numer*r.numer, denom*r.denom )
}
```
* Marked Points:
	* def x = 1 : passing by name; val x = 1 : passing by value. Optimization: How freqenct they are used and any potiential error requiring to use passing by name.
	* Operator charactors and those weird charactors can be used as identifier, so use infix operation is possible. Also precedence of operators are predefined in Scala. 
	* Require or assert function are predefined functions in scala. require: used to enforce a precondition on the caller of the function; assert: to check the code of the function itself. 
	* Recursive method need result type.
	* Read above toStrings to see override.
	* Self reference
	* Use of unary_ to define infix operator.


---
### Scala Notes on Jan 3

```scala
object Exercise1 extends App{
//      val n1 = new IntSet(3, new Empty, new Empty) //  class IntSet is abstract; cannot be instantiated
        val n1 = new NonEmpty(3, Empty, Empty)
        n1.toString_IntSet
        val n2 = n1 incl 4
        n2.toString_IntSet
}

abstract class IntSet {
        def incl(x: Int): IntSet
        def contains(x: Int): Boolean
        def toString_IntSet
        def union(other: IntSet): IntSet
}

/**
class Empty extends IntSet{
        def contains(x: Int) = false
        def incl(x: Int): IntSet = new NonEmpty(x, new Empty, new Empty)
        def toString_IntSet = println(".")
        override def toString = "."
}
*/

/** First optimization: we only need one single empty IntSet, so use: */
object Empty extends IntSet{ 
        def contains(x: Int) = false
        def incl(x: Int): IntSet = new NonEmpty(x, Empty, Empty)
        def toString_IntSet = println(".")
        override def toString = "."
        def union(other: IntSet) = other
}
/** This defines a singleton object called Empty, no other Emyty instances can be created, singleton object are values, so Empty evaluate itself*/
class NonEmpty(elem: Int, left: IntSet, right: IntSet) extends IntSet{
        def contains(x: Int): Boolean = {
                if (x>elem) right contains x
                else if (x<elem) left contains x
                else true }

        def incl(x: Int): IntSet = {
                if (x>elem) new NonEmpty(elem, left, right incl x)
                else if (x<elem) new NonEmpty(elem, left incl x, right)
                else this }

        def toString_IntSet = println("{" + left + elem + right + "}")
        override def toString = "{"+ left + elem + right + "}"
        def union(other: IntSet): IntSet = ((left union right) union other) incl elem
}
```

* dynamic method dispatch model in object-oriented languages: dynamic binding is analogous to higher-order functions in functional languages.
* abstract class
* extends: an object of type Empty and NonEmpty can be used wherever an object of type IntSet is required
* override
* singleton object
* In standalone application in Scala, each application contains an object with a main metho, e.g.

```
     object Hello{
                def main(args: Array[String)] = println("Hello World")
        }
```
* To place a class or object inside a package, use: **package progfun.example** at the top of your source code
* To use a class or object inside a package, use import: **import week3.Rational, import week3.{Rational, Hello}, import week3._**
* Standard Scala Library: <a href="http://www.scala-lang.org/api/current/" > http://www.scala-lang.org/api/current/ </a>
* If a class wants to have several supertypes, use trait keyword: classes, objects and traits can only inherit from one class, but many traits. E.g. **class Square extends Shape with Plannar with Movable**. Traits resemble interfaces in Java, but are more powerful because they can contain fields and concrete methods. But traits cannot have parameters, only class can.
* Nothing is at the bottom of Scala's type hierarchy. It is used to signal abnormal termination and as an element type of empty collections
* Scala exception handling: throw Exc
* Null type: every reference class type also has Null as a value. Null is a subcctype of every class that inherits from object; it is incompatible with subtype of AnyVal
     * val x = null //ok
     * val x: String = null //ok
     * val x: Int = null //not ok

![Class Hierarchy](https://github.com/YuxinxinChen/YuxinxinChen.github.io/tree/master/images/classhierarchy.png "Class Hierarchy")

---
### Scala Study on Jan 4 and my Lyft coupon expired

* You cann't do:

```scala
 def foo(f: Int=>Int)(var a: Double). 
```
Mutating the input parameters is often seen as bad style and makes it harder to reason about code. The reason could be simple: alias problem. so: 

```scala
def foo(f: Int=>Int)(val a: Double)
```
* Type parameters do not effect evaluation in Scala, this is called type erasure

```scala
package lesson4

trait List[T] { // make it scalable and apply to kinds of types lists. Use type parameter: [T]. Not only class, functions also can have type parameters: def singleton[T](elem: T) = new Cons[T](elem, new Nil[T])
        def isEmpty: Boolean
        def head: T
        def tail: List[T]
}

class Cons[T](val head: T, val tail: List[T]) extends List[T]{
        def isEmpty = false
        // head and tail is defined in cons parameters
}

class Nil[T] extends List[T]{
        def isEmpty = true
        def head = throw new NoSuchElementException("Nil.head")
        def tail = throw new NoSuchElementException("Nil.tail")
}
``` 
In other file:

```scala
import lesson4._

object nth extends App{
        def nth[T]( n: Int, xs: List[T]) :T = {
                if (xs.isEmpty) throw new IndexOutOfBoundsException
                else if (n==0) xs.head
                else nth(n-1, xs.tail)
        }
        val list1 = new Cons(1, new Cons(2, new Cons(3, new Nil)))
        println(nth(2, list1))
}
```
